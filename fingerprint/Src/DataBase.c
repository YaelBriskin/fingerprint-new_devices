#include "../Inc/DataBase.h"

sqlite3 *db_attendance;
pthread_mutex_t sqlMutex;

/**
 * @brief Retrieves the next available ID from the database.
 *
 * This function queries the 'sqlite_sequence' table to get the current sequence number
 * for the 'employees' table and returns the next available ID.
 *
 * @return The next available ID.
 */
int getNextAvailableID()
{
    int id = 0;
    char *query = "SELECT seq FROM sqlite_sequence WHERE name = 'employees'";
    sqlite3_stmt *stmt;

    if (sqlite3_prepare_v2(db_attendance, query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to execute query: %s", sqlite3_errmsg(db_attendance));
        return id;
    }

    if (sqlite3_step(stmt) == SQLITE_ROW)
        id = sqlite3_column_int(stmt, 0);

    sqlite3_finalize(stmt);
    return id + 1;
}
/**
 * @brief Opens the attendance database and initializes the required tables.
 *
 * This function opens a connection to the 'employee_attendance.db' database.
 * If the database does not exist, it will be created automatically. It also
 * creates the 'attendance' and 'employees' tables if they do not already exist.
 */
void DB_open()
{
    char *err_msg = NULL;
    int result;

    // Open a connection to the "attendance" database
    result = sqlite3_open(g_database_path, &db_attendance);
    if (result != SQLITE_OK)
    {
        char log_message[MAX_LOG_MESSAGE_LENGTH];
        snprintf(log_message, MAX_LOG_MESSAGE_LENGTH, "Failed to open attendance database: %s (SQLite error code: %d)", sqlite3_errmsg(db_attendance), result);
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", log_message ,NULL);
        exit(EXIT_FAILURE);
    }

    // Create the 'attendance' table if it does not exist
    const char *create_attendance_table_query = "CREATE TABLE IF NOT EXISTS attendance ("
                                                "ID INTEGER,"
                                                "Timestamp INTEGER NOT NULL,"
                                                "Direction TEXT NOT NULL,"
                                                "Saved TEXT DEFAULT 'X' NOT NULL,"
                                                "FPM INTEGER NOT NULL,"
                                                "FOREIGN KEY(ID) REFERENCES employees(ID));";

    result = sqlite3_exec(db_attendance, create_attendance_table_query, 0, 0, &err_msg);
    if (result != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to create table: %s", err_msg);
        sqlite3_free(err_msg);
        exit(EXIT_FAILURE);
    }
    // Create the 'employees' table if it does not exist
    const char *create_employees_table_query = "CREATE TABLE IF NOT EXISTS employees ("
                                               "ID INTEGER PRIMARY KEY AUTOINCREMENT);";

    result = sqlite3_exec(db_attendance, create_employees_table_query, 0, 0, &err_msg);
    if (result != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR,__func__, "format", "Failed to create employees table: %s", err_msg);
        sqlite3_free(err_msg);
        exit(EXIT_FAILURE);
    }
    // Initialize the mutex
    if (pthread_mutex_init(&sqlMutex, NULL) != MUTEX_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to initialize mutex", NULL);
        exit(EXIT_FAILURE);
    }
}
/**
 * @brief Adds a new employee to the database.
 *
 * This function inserts a new record into the 'employees' table. The ID is
 * automatically generated by the database.
 */
void DB_newEmployee()
{
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex",NULL);
        return ;
    }
    sqlite3_stmt *stmt;
    const char *sql = "INSERT INTO employees DEFAULT VALUES;";
    // Preparing the request
    if (sqlite3_prepare_v2(db_attendance, sql, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format","Failed to prepare statement: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex); 
        return;
    }
    // Execute the request
    if (sqlite3_step(stmt) != SQLITE_DONE)
        LOG_MESSAGE(LOG_ERR, __func__, "format","Failed to insert new employee: %s", sqlite3_errmsg(db_attendance));
    // Finish the request
    sqlite3_finalize(stmt);
    // Release the mutex after performing operations
    pthread_mutex_unlock(&sqlMutex);
}
/**
 * @brief Writes an attendance record to the database.
 *
 * This function inserts a new record into the 'attendance' table.
 *
 * @param ID The ID of the employee.
 * @param Timestamp The timestamp of the attendance record.
 * @param direction The direction of the attendance ("in" or "out").
 * @param FPM The fingerprint match status ("true" or "false").
 * @return 1 on success, 0 on failure.
 */
Status_t DB_write(int ID, int Timestamp, const char *direction, const char *FPM)
{
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr","Failed to lock mutex",NULL);
        return FAILED;
    }
    Status_t result = SUCCESS;
    sqlite3_stmt *stmt;
    // SQL query to insert data into the table
    const char *sql = "INSERT INTO attendance (ID, Timestamp, Direction, FPM) VALUES (?, ?, ?, ?);";
    // Prepare the request
    if (sqlite3_prepare_v2(db_attendance, sql, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }
    // Binding values to request parameters
    sqlite3_bind_int(stmt, 1, ID);
    sqlite3_bind_int(stmt, 2, Timestamp);
    sqlite3_bind_text(stmt, 3, direction, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, FPM, -1, SQLITE_STATIC);
    // Execute the request
    if (sqlite3_step(stmt) != SQLITE_DONE)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "The request failed: %s", sqlite3_errmsg(db_attendance));
        result =  FAILED;
    }
    // Finish the request
    sqlite3_finalize(stmt);
    // Release the mutex after performing operations
    pthread_mutex_unlock(&sqlMutex);
    return result;
}
/**
 * @brief Closes the connection to the database.
 *
 * This function closes the connection to the 'employee_attendance.db' database
 * and destroys the mutex.
 */
void DB_close()
{
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_OK)
    {
        // Close the connection to the database
        sqlite3_close(db_attendance);
        // Release the mutex after performing operations
        pthread_mutex_unlock(&sqlMutex);
    }
    else
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
    }
}
/**
 * @brief Finds unsent attendance records in the database and sends them to the server.
 *
 * This function queries the 'attendance' table for records where the 'Saved' column
 * is 'X', indicating they have not been sent to the server. It attempts to send these
 * records to the server and updates the 'Saved' column to 'V' upon success.
 *
 * @return 1 if there were records sent successfully, -1 on failure, 0 if no records were found.
 */
int DB_find()
{
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        return ERROR;
    }
    char *query = "SELECT ID, Timestamp, Direction, FPM FROM attendance WHERE Saved = 'X';";
    sqlite3_stmt *stmt;
    int check = 0;

    // Prepare the request
    if (sqlite3_prepare_v2(db_attendance, query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex);
        return ERROR;
    }
    // Processing query results
    while (sqlite3_step(stmt) == SQLITE_ROW)
    {
        int id = sqlite3_column_int(stmt, 0);
        int timestamp = sqlite3_column_int(stmt, 1);
        const char *direction = (const char *)sqlite3_column_text(stmt, 2);
        const char *FPM = (const char *)sqlite3_column_text(stmt, 3);

        // HTTP request
        if (send_json_data(id, direction, timestamp, FPM) == SUCCESS)
        {
            DB_update(id);
            check = 1;
        }
        else
            LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Error sending HTTP request", NULL);
    }
        // Finish the request
    if (stmt != NULL)
    {
        sqlite3_finalize(stmt);
    }
    pthread_mutex_unlock(&sqlMutex);
    return check;
}
/**
 * @brief Updates the 'Saved' status of a record to 'V'.
 *
 * This function updates the 'Saved' column of a record in the 'attendance' table
 * to 'V' indicating that it has been successfully sent to the server.
 *
 * @param id The ID of the record to update.
 */
void DB_update(int id)
{
    char *updateQuery = NULL;
    int rc = asprintf(&updateQuery, "UPDATE attendance SET Saved = 'V' WHERE ID = %d;", id);
    if (rc == -1 || updateQuery == NULL)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Memory allocation error during query creation.", NULL);
        return;
    }    
    char *err_msg = 0;
    rc = sqlite3_exec(db_attendance, updateQuery, 0, 0, &err_msg);

    if (rc != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to update data in the database: %s", err_msg);
        // fprintf(stderr, "Failed to update data in the database: %s\n", err_msg);
        sqlite3_free(err_msg);
    }
    free(updateQuery);
}
/**
 * @brief Deletes an employee record from the database.
 *
 * This function deletes a record from the 'employees' table based on the specified ID.
 *
 * @param ID The ID of the employee to delete.
 * @return SUCCESS on success, FAILED on failure.
 */
Status_t DB_delete(int ID)
{
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        return FAILED;
    }

    char *sql_query = NULL;
    // Create SQL query for deletion
    int ret = asprintf(&sql_query, "DELETE FROM employees WHERE ID = %d;", ID);
    if (!sql_query || ret == -1)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Memory allocation error",NULL);
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }

    sqlite3_stmt *stmt;
    // Prepare the SQL statement
    if (sqlite3_prepare_v2(db_attendance, sql_query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        free(sql_query); // Free allocated memory
        pthread_mutex_unlock(&sqlMutex);
        return FAILED; // Return error code
    }

    free(sql_query); // Free allocated memory as it is no longer needed

    // Execute the prepared statement
    if (sqlite3_step(stmt) != SQLITE_DONE)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to delete record: %s", sqlite3_errmsg(db_attendance));
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }

    // Check if any rows were affected
    if (sqlite3_changes(db_attendance) == 0)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "No record found with ID %d", ID);
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }

    // Log successful deletion
    char log_message[MAX_LOG_MESSAGE_LENGTH];
    snprintf(log_message, MAX_LOG_MESSAGE_LENGTH, "ID %d deleted from DB", ID);
    LOG_MESSAGE(LOG_ERR, __func__, "stderr", log_message,NULL);

    // Clean up resources
    sqlite3_finalize(stmt);
    pthread_mutex_unlock(&sqlMutex);

    return SUCCESS;
}

/**
 * @brief Deletes old attendance records from the database.
 *
 * This function deletes records from the 'attendance' table where the timestamp
 * is older than two months from the specified time.
 *
 * @param lastDay The time threshold for deleting old records.
 */
void DB_delete_old_records(time_t lastDay)
{
    // Convert time_t to struct tm
    struct tm *timeinfo = localtime(&lastDay);
    timeinfo->tm_mon -= g_month; 
    mktime(timeinfo);

    time_t timestamp_threshold = mktime(timeinfo);

    char *sql_query = NULL;
    // Create SQL query for deletion
    asprintf(&sql_query, "DELETE FROM attendance WHERE Timestamp < %ld;", (long)timestamp_threshold);
    if (!sql_query)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Memory allocation error", NULL);
        return;
    }
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        free(sql_query);
        return;
    }
    sqlite3_stmt *stmt;
    // Prepare the SQL statement
    if (sqlite3_prepare_v2(db_attendance, sql_query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        free(sql_query);
        pthread_mutex_unlock(&sqlMutex);
        return;
    }

    // Free the allocated memory for SQL query since it is no longer needed
    free(sql_query);

    // Execute the prepared statement
    if (sqlite3_step(stmt) != SQLITE_DONE)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to delete records: %s", sqlite3_errmsg(db_attendance));
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return;
    }
    // Clean up resources
    sqlite3_finalize(stmt);
    pthread_mutex_unlock(&sqlMutex);
}

/**
 * @brief Checks if an employee ID exists in the database.
 *
 * This function checks if a given ID exists in the 'employees' table.
 *
 * @param id The ID to check.
 * @return SUCCESS if the ID exists, FAILED if it does not, or ERROR on query failure.
 */
int DB_check_id_exists(int id)
{
    int status = FAILED; 
    // Lock the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        return ERROR;
    }
    const char *query = "SELECT 1 FROM employees WHERE ID = ? LIMIT 1;";
    sqlite3_stmt *stmt;

    // Prepare the SQL query
    if (sqlite3_prepare_v2(db_attendance, query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex);
        return ERROR;
    }
    // Bind the ID parameter to the query
    if (sqlite3_bind_int(stmt, 1, id) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to bind parameter: %s", sqlite3_errmsg(db_attendance));
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return ERROR;
    }
    int result = sqlite3_step(stmt);
    if (result == SQLITE_ROW)
    {
        // ID found
        status = SUCCESS;
    }
    else if (result == SQLITE_DONE)
    {
        // ID not found
        status = FAILED;
    }
    else
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "SQL error during step: %s", sqlite3_errmsg(db_attendance));
    }
    // Finalize the statement and unlock the mutex
    sqlite3_finalize(stmt);
    pthread_mutex_unlock(&sqlMutex);

    return status;
}

/**
 * @brief Restores a record in the database with default values.
 *
 * Attempts to insert a record with the specified ID back into the database if it was previously
 * deleted. The record is inserted with default values for columns other than the ID.
 *
 * @param id The ID of the record to be restored.
 * @return Returns `SUCCESS` if the record is successfully restored in the database.
 *         Returns `FAILED` if the insertion fails or if any error occurs during the operation.
 */
int DB_restore(int id)
{
    // Mutex lock for thread safety
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        return ERROR;
    }
    
    // SQL query to restore the record
    const char *query = "INSERT INTO employees (ID) VALUES (?);";
    sqlite3_stmt *stmt;

    // Prepare the SQL statement
    if (sqlite3_prepare_v2(db_attendance, query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare query: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }

    // Bind the ID parameter
    if (sqlite3_bind_int(stmt, 1, id) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to bind parameter: %s", sqlite3_errmsg(db_attendance));
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }
    // Execute the SQL statement
    if (sqlite3_step(stmt) != SQLITE_DONE)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to execute query: %s", sqlite3_errmsg(db_attendance));
        sqlite3_finalize(stmt);
        pthread_mutex_unlock(&sqlMutex);
        return FAILED;
    }

    // Finalize the statement and unlock the mutex
    sqlite3_finalize(stmt);
    pthread_mutex_unlock(&sqlMutex);
    
    return SUCCESS;
}
int DB_find_ID(int id_to_check)
{
    // Obtain the mutex before accessing the database
    if (pthread_mutex_lock(&sqlMutex) == MUTEX_ERROR)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to lock mutex", NULL);
        return ERROR;
    }

    sqlite3_stmt *stmt;
    int result = 0;

    char *sql_query = NULL;
    // Allocate memory for the query
    if (asprintf(&sql_query, "SELECT ID FROM attendance WHERE Saved = 'X' AND ID = %d;", id_to_check) == -1)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "stderr", "Failed to allocate memory for SQL query", NULL);
        pthread_mutex_unlock(&sqlMutex);
        return ERROR;
    }

    // Prepare the request
    if (sqlite3_prepare_v2(db_attendance, sql_query, -1, &stmt, NULL) != SQLITE_OK)
    {
        LOG_MESSAGE(LOG_ERR, __func__, "format", "Failed to prepare request: %s", sqlite3_errmsg(db_attendance));
        pthread_mutex_unlock(&sqlMutex);
        return ERROR;
    }

    // Check if there are any rows returned
    if (sqlite3_step(stmt) == SQLITE_ROW)
    {
        // If a row exists, it means there are unsent data for the given ID
        result = SUCCESS;
    }
    // Finalize the statement
    if (stmt != NULL)
    {
        sqlite3_finalize(stmt);
    }

    // Free the memory allocated for the query
    free(sql_query);
    pthread_mutex_unlock(&sqlMutex);
    return result;
}